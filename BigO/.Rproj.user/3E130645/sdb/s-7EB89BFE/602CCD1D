{
    "contents" : "#'kaggle competition\n#'\n#'@param training data set for training\n#'@param test data set for test\n#'\n#'@import assertthat\n#'@import caret\n#'@import gbm\n#'@import randomForest\n#'@import functional\n#'\n#'@return a dataframe with predictied class on test data set\n#'\n#'\n\n\nBigO <- function(training, test.real, outputCSV=TRUE){\n  if (!require(\"assertthat\")) install.packages(\"assertthat\")\n  if (!require(\"caret\")) install.packages(\"caret\")\n  if (!require(\"gbm\")) install.packages(\"gbm\")\n  if (!require(\"randomForest\")) install.packages(\"randomForest\")\n  if (!require(\"functional\")) install.packages(\"functional\")\n\n\n  not_empty(X)\n  not_empty(y)\n\n\n  ##PreProp\n  #read data and remove non-predictors\n  training <- read.csv(\"news_popularity_training.csv\")[,-c(1,2,3)]\n  test.real <- read.csv(\"testReal.csv\")[,-c(1,2,3)]\n  training <- training[-22686,]\n\n\n  training$n_non_stop_words <- NULL\n  test.real$n_non_stop_words <- NULL\n\n\n  #transform response to factor\n  training$popularity <- as.factor(training$popularity)\n\n\n  #remove repetative variable\n  rep.dummy <-findLinearCombos(training)$remove\n  training[,rep.dummy] <-data.frame(NULL)\n  test.real[,rep.dummy] <- data.frame(NULL)\n\n\n  #make num_keywords a categorical variable\n  training$num_keywords <- as.factor(training$num_keywords)\n  test.real$num_keywords <- as.factor(test.real$num_keywords)\n\n\n  #dummy variable name\n\n\n  dummy_data_channel <- grep(\"data_channel\", names(training))\n  dummy_data_channel.name <- names(training)[dummy_data_channel]\n\n\n  data_channel <- as.matrix(training[dummy_data_channel.name]) %*% 1:length(dummy_data_channel)\n  data_channel <- factor(as.vector(data_channel))\n\n\n  training[dummy_data_channel.name] <- data.frame(NULL)\n  training <- data.frame(data_channel = data_channel, training)\n\n\n  data_channel <- as.matrix(test.real[dummy_data_channel.name]) %*% 1:length(dummy_data_channel)\n  data_channel <- factor(as.vector(data_channel))\n\n\n  test.real[dummy_data_channel.name] <- data.frame(NULL)\n  test.real <- data.frame(data_channel = data_channel, test.real)\n\n\n  dummy_weekday <- grep(\"weekday\", names(training))\n  dummy_weekday.name <- names(training)[dummy_weekday]\n\n\n  weekday <- as.matrix(training[dummy_weekday.name]) %*% 1:length(dummy_weekday)\n  weekday <- factor(as.vector(weekday))\n\n\n  training[dummy_weekday.name] <- data.frame(NULL)\n  training <- data.frame(weekday = weekday, training)\n\n\n  weekday <- as.matrix(test.real[dummy_weekday.name]) %*% 1:length(dummy_weekday)\n  weekday <- factor(as.vector(weekday))\n\n\n  test.real[dummy_weekday.name] <- data.frame(NULL)\n  test.real <- data.frame(weekday = weekday, test.real)\n\n\n  #preprocess the non-dummy variable\n  category.name <- c(\"weekday\", \"data_channel\", \"num_keywords\")\n  training.pp <- preProcess(training[, !names(training) %in% c(category.name,\"popularity\")],\n                            method = c(\"center\", \"scale\"))\n\n\n  training <- predict(training.pp, newdata = training)\n  test.real <- predict(training.pp, newdata = test.real)\n\n\n  set.seed(111)\n\n\n  #RF1\n  Grid.rf1 <-  expand.grid(mtry = 7)\n  fitControl.rf1<- trainControl(method = \"none\")\n  rf1 <- train(popularity ~ ., data = training,\n               ntree=750,\n               method = \"rf\",\n               trControl = fitControl.rf1,\n               verbose = FALSE,\n               tuneGrid = Grid.rf1\n               )\n\n\n  #RF2\n  Grid.rf2 <-  expand.grid(mtry = 6)\n  fitControl.rf2<- trainControl(method = \"none\")\n  rf2 <- train(popularity ~ ., data = training,\n               ntree=1000,\n               method = \"rf\",\n               trControl = fitControl.rf2,\n               verbose = FALSE,\n               tuneGrid = Grid.rf2\n               )\n\n\n  #RF3\n  Grid.rf3 <-  expand.grid(mtry = 8)\n  fitControl.rf3<- trainControl(method = \"none\")\n  rf3 <- train(popularity ~ ., data = training,\n               ntree=1250,\n               method = \"rf\",\n               trControl = fitControl.rf3,\n               verbose = FALSE,\n               tuneGrid = Grid.rf3\n  )\n\n\n\n  set.seed(111)\n\n\n  #gbm1\n  Grid.gbm1 <-  expand.grid(interaction.depth = 13,\n                          n.trees = c(800),\n                          shrinkage = 0.008,\n                          n.minobsinnode = 10)\n  fitControl.gbm1 <- trainControl(method = \"none\")\n  gbm1 <- train(popularity ~ ., data = training,\n                  method = \"gbm\",\n                  trControl = fitControl.gbm1,\n                  verbose = FALSE,\n                  tuneGrid = Grid.gbm1)\n\n\n  #gbm2\n  Grid.gbm2 <-  expand.grid(interaction.depth = 10,\n                            n.trees = c(2000),\n                            shrinkage = 0.003,\n                            n.minobsinnode = 15)\n  fitControl.gbm2 <- trainControl(method = \"none\")\n  gbm2 <- train(popularity ~ ., data = training,\n                method = \"gbm\",\n                trControl = fitControl.gbm2,\n                verbose = FALSE,\n                tuneGrid = Grid.gbm2)\n\n\n  #gbm3\n  Grid.gbm3 <-  expand.grid(interaction.depth = 8,\n                            n.trees = c(1000),\n                            shrinkage = 0.01,\n                            n.minobsinnode = 15)\n  fitControl.gbm3 <- trainControl(method = \"none\")\n  gbm3 <- train(popularity ~ ., data = training,\n                method = \"gbm\",\n                trControl = fitControl.gbm3,\n                verbose = FALSE,\n                tuneGrid = Grid.gbm3)\n\n\n  #prediction\n  pred.rf1 <- predict(rf1, test.real)\n  pred.rf2 <- predict(rf2, test.real)\n  pred.rf3 <- predict(rf3, test.real)\n\n\n  pred.gbm1 <- predict(gbm1, test.real)\n  pred.gbm2 <- predict(gbm2, test.real)\n  pred.gbm3 <- predict(gbm3, test.real)\n\n\n  #Take majority rule\n  predMatrix <- cbind(pred.rf1, pred.rf2, pred.rf3, pred.gbm1, pred.gbm2, pred.gbm3)\n\n\n  pred.avg<-sapply(1:nrow(m), function(idx) {\n    # get the number of time each entry in matrix occurs\n    t <- table(t(m[idx, ]))\n    # get the maximum count\n    t.max <- max(t)\n    # sample 1 value that equate to maximum count\n    t <- as.numeric(names(t[t == t.max]))\n    t <- t[sample(length(t),1)]\n  })\n\n\n  #output\n  result <- data.frame(id = 30001:39644, popularity = pred.avg)\n\n\n  if(outputCSV){\n    write.csv(result, \"BigO.csv\", row.names = FALSE)\n  }\n\n\n  return(result)\n\n\n}\n",
    "created" : 1458255018124.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1169092449",
    "id" : "602CCD1D",
    "lastKnownWriteTime" : 1458255247,
    "path" : "C:/Users/Riskneutral/Desktop/15D012 Advanced Computational Methods/competition/BigO/R/BigO.R",
    "project_path" : "R/BigO.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}